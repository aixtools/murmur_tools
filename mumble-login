#!/usr/bin/env python3
"""Test password-based authentication against a Mumble server.

Emulates the Mumble GUI client cert-mismatch recovery flow:
  1. Connect (no password, or with --password if given).
  2. If server rejects with WrongUserPW and no password was supplied,
     prompt for a password and reconnect — exactly what the GUI does.
"""

import ssl
import sys
import threading
import getpass
import argparse

# Python 3.12+ compatibility: ssl.wrap_socket was removed
if not hasattr(ssl, 'wrap_socket'):
    def wrap_socket(sock, keyfile=None, certfile=None, server_side=False,
                    cert_reqs=ssl.CERT_NONE, ssl_version=None,
                    ca_certs=None, do_handshake_on_connect=True,
                    suppress_ragged_eofs=True, ciphers=None):
        context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT if not server_side else ssl.PROTOCOL_TLS_SERVER)
        context.check_hostname = False
        context.verify_mode = cert_reqs
        if certfile:
            context.load_cert_chain(certfile, keyfile)
        if ca_certs:
            context.load_verify_locations(ca_certs)
        if ciphers:
            context.set_ciphers(ciphers)
        return context.wrap_socket(sock, server_side=server_side,
                                   do_handshake_on_connect=do_handshake_on_connect,
                                   suppress_ragged_eofs=suppress_ragged_eofs)
    ssl.wrap_socket = wrap_socket

import pymumble_py3 as pymumble
from pymumble_py3 import mumble_pb2
from pymumble_py3.constants import (
    PYMUMBLE_CONN_STATE_CONNECTED,
    PYMUMBLE_CONN_STATE_FAILED,
    PYMUMBLE_MSG_TYPES_REJECT,
    PYMUMBLE_MSG_TYPES_SERVERSYNC,
)

REJECT_TYPE_NAMES = {
    0: "None (unknown reason)",
    1: "WrongVersion (incompatible protocol version)",
    2: "InvalidUsername (username format not accepted)",
    3: "WrongUserPW (wrong user or certificate password)",
    4: "WrongServerPW (wrong server password)",
    5: "UsernameInUse (username already connected)",
    6: "ServerFull (server at capacity)",
    7: "NoCertificate (certificate required but not provided)",
    8: "AuthenticatorFail (external authenticator failure)",
    9: "NoNewConnections (server not accepting connections)",
}

WRONG_USER_PW = 3  # RejectType enum value


class DiagnosticMumble(pymumble.Mumble):
    """Captures full Reject and ServerSync details for diagnostic output."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.reject_info = None
        self.sync_info = None

    def dispatch_control_message(self, type, message):
        if type == PYMUMBLE_MSG_TYPES_REJECT:
            mess = mumble_pb2.Reject()
            mess.ParseFromString(message)
            rtype = mess.type
            self.reject_info = {
                'type':      rtype,
                'type_name': REJECT_TYPE_NAMES.get(rtype, f"Unknown ({rtype})"),
                'reason':    mess.reason or '(no reason provided)',
            }
        elif type == PYMUMBLE_MSG_TYPES_SERVERSYNC:
            mess = mumble_pb2.ServerSync()
            mess.ParseFromString(message)
            self.sync_info = {
                'session':       mess.session,
                'max_bandwidth': mess.max_bandwidth,
                'welcome_text':  mess.welcome_text or None,
                'permissions':   mess.permissions,
            }
        super().dispatch_control_message(type, message)


def _suppress_rejected_errors():
    """Install a threading excepthook that hides ConnectionRejectedError tracebacks.
    Those are expected and handled via client.connected / client.reject_info."""
    orig = threading.excepthook
    def _hook(args):
        from pymumble_py3.errors import ConnectionRejectedError
        if args.exc_type is ConnectionRejectedError:
            return
        orig(args)
    threading.excepthook = _hook


def try_login(server, port, username, password):
    """Attempt one login. Returns the DiagnosticMumble instance after is_ready()."""
    client = DiagnosticMumble(
        host=server,
        user=username,
        port=port,
        password=password,
        reconnect=False,
    )
    client.daemon = True
    client.start()
    client.is_ready()
    return client


def print_success(client):
    print("SUCCESS: Authenticated.")
    if client.sync_info:
        s = client.sync_info
        print(f"  Session ID   : {s['session']}")
        print(f"  Max bandwidth: {s['max_bandwidth']} bps")
        print(f"  Permissions  : 0x{s['permissions']:08x}")
        if s['welcome_text']:
            print(f"  Welcome      : {s['welcome_text']}")
    client.stop()


def print_failure(client):
    print("FAILED: Connection rejected.", file=sys.stderr)
    if client.reject_info:
        r = client.reject_info
        print(f"  Reject type: {r['type_name']}", file=sys.stderr)
        print(f"  Reason     : {r['reason']}", file=sys.stderr)
    else:
        print("  (connection failed before server responded — check host/port/TLS)",
              file=sys.stderr)


def main():
    parser = argparse.ArgumentParser(
        description='Test password-based login to a Mumble server.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument('--server',   default='127.0.0.1', help='Mumble server hostname or IP')
    parser.add_argument('--port',     default=64738, type=int, help='Mumble server port')
    parser.add_argument('--username', required=True, help='Username')
    parser.add_argument('--password', default=None,
                        help='Password. If omitted and server requests one, you will be prompted.')
    args = parser.parse_args()

    _suppress_rejected_errors()

    # --- First attempt ---
    password = args.password or ''
    print(f"Connecting to {args.server}:{args.port} as '{args.username}' ...")
    client = try_login(args.server, args.port, args.username, password)

    if client.connected == PYMUMBLE_CONN_STATE_CONNECTED:
        print_success(client)
        sys.exit(0)

    # --- Cert mismatch recovery: server says WrongUserPW and we had no password ---
    # This mirrors the Mumble GUI flow: receive WrongUserPW → show password dialog → reconnect.
    # On the server side (murmur/Messages.cpp), a correct password overrides cert mismatch entirely.
    if (args.password is None
            and client.reject_info
            and client.reject_info['type'] == WRONG_USER_PW):
        print(f"Server: {client.reject_info['reason']}")
        print("User is registered and requires a password or matching certificate.")
        try:
            password = getpass.getpass(f"Password for '{args.username}': ")
        except (KeyboardInterrupt, EOFError):
            print()
            sys.exit(1)

        if not password:
            print("No password entered.", file=sys.stderr)
            sys.exit(1)

        print(f"Reconnecting with password ...")
        client = try_login(args.server, args.port, args.username, password)

        if client.connected == PYMUMBLE_CONN_STATE_CONNECTED:
            print_success(client)
            sys.exit(0)

    print_failure(client)
    sys.exit(1)


if __name__ == '__main__':
    main()
